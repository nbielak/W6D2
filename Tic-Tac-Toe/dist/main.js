!function(n){var e={};function r(t){if(e[t])return e[t].exports;var o=e[t]={i:t,l:!1,exports:{}};return n[t].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=n,r.c=e,r.d=function(n,e,t){r.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},r.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},r.t=function(n,e){if(1&e&&(n=r(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)r.d(t,o,function(e){return n[e]}.bind(null,o));return t},r.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(e,"a",e),e},r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},r.p="",r(r.s=1)}([function(n,e){n.exports=function(n){this.msg=n}},function(n,e,r){r(2),n.exports=r(6)},function(n,e,r){const t=r(3),o=r(4);$(()=>{const n=new o,e=$(".ttt");new t(n,e)})},function(n,e){n.exports=class{constructor(n,e){console.log(e),this.game=n,this.$el=e,this.setupBoard(),this.bindEvents()}bindEvents(){$("ul").on("click",n=>{const e=$(n.target);this.makeMove(e)})}makeMove(n){const e=n.data("pos"),r=this.game.board;r.isEmptyPos(e)||alert("Invalid Move!");let t=this.game.currentPlayer;if(this.game.playMove(e),"x"===t?n.addClass("x-clicked"):n.addClass("o-clicked"),n.append(t),r.isOver()){const n=r.winner();n?alert(`${n} wins!`):alert("Cat's Game!")}}setupBoard(){const n=$("<ul></ul>");n.addClass("board");for(let e=0;e<3;e++)for(let r=0;r<3;r++){const t=$("<li></li>");t.addClass("space"),t.data("pos",[e,r]),n.append(t)}this.$el.append(n)}}},function(n,e,r){const t=r(5),o=r(0);n.exports=class{constructor(){this.board=new t,this.currentPlayer=t.marks[0]}isOver(){return this.board.isOver()}playMove(n){this.board.placeMark(n,this.currentPlayer),this.swapTurn()}promptMove(n,e){this.board.print(),console.log(`Current Turn: ${this.currentPlayer}`),n.question("Enter rowIdx: ",r=>{const t=parseInt(r);n.question("Enter colIdx: ",n=>{const r=parseInt(n);e([t,r])})})}run(n,e){this.promptMove(n,r=>{try{this.playMove(r)}catch(n){if(!(n instanceof o))throw n;console.log(n.msg)}this.isOver()?(this.board.print(),this.winner()?console.log(`${this.winner()} has won!`):console.log("NO ONE WINS!"),e()):this.run(n,e)})}swapTurn(){this.currentPlayer===t.marks[0]?this.currentPlayer=t.marks[1]:this.currentPlayer=t.marks[0]}winner(){return this.board.winner()}}},function(n,e,r){const t=r(0);class o{constructor(){this.grid=o.makeGrid()}isEmptyPos(n){if(!o.isValidPos(n))throw new t("Is not valid position!");return null===this.grid[n[0]][n[1]]}isOver(){if(null!=this.winner())return!0;for(let n=0;n<3;n++)for(let e=0;e<3;e++)if(this.isEmptyPos([n,e]))return!1;return!0}placeMark(n,e){if(!this.isEmptyPos(n))throw new t("Is not an empty position!");this.grid[n[0]][n[1]]=e}print(){const n=[];for(let e=0;e<3;e++){const r=[];for(let n=0;n<3;n++)r.push(this.grid[e][n]?this.grid[e][n]:" ");n.push(`${r.join("|")}\n`)}console.log(n.join("-----\n"))}winner(){const n=[[[0,0],[0,1],[0,2]],[[1,0],[1,1],[1,2]],[[2,0],[2,1],[2,2]],[[0,0],[1,0],[2,0]],[[0,1],[1,1],[2,1]],[[0,2],[1,2],[2,2]],[[0,0],[1,1],[2,2]],[[2,0],[1,1],[0,2]]];for(let e=0;e<n.length;e++){const r=this.winnerHelper(n[e]);if(null!=r)return r}return null}winnerHelper(n){for(let e=0;e<o.marks.length;e++){const r=o.marks[e];let t=!0;for(let e=0;e<3;e++){const o=n[e];this.grid[o[0]][o[1]]!=r&&(t=!1)}if(t)return r}return null}static isValidPos(n){return 0<=n[0]&&n[0]<3&&0<=n[1]&&n[1]<3}static makeGrid(){const n=[];for(let e=0;e<3;e++){n.push([]);for(let r=0;r<3;r++)n[e].push(null)}return n}}o.marks=["x","o"],n.exports=o},function(module,exports){!function(n){var e={};function r(t){if(e[t])return e[t].exports;var o=e[t]={i:t,l:!1,exports:{}};return n[t].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=n,r.c=e,r.d=function(n,e,t){r.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},r.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},r.t=function(n,e){if(1&e&&(n=r(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)r.d(t,o,function(e){return n[e]}.bind(null,o));return t},r.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(e,"a",e),e},r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},r.p="",r(r.s="./js/main.js")}({"./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('const View = __webpack_require__(/*! ./ttt-view.js */ "./js/ttt-view.js");\nconst Game = __webpack_require__(/*! ./solution/game.js */ "./js/solution/game.js");\n\n$( () => {\n  const game = new Game();\n  const view_el = $(".ttt");\n  const view = new View(game, view_el);\n});\n\n\n//# sourceURL=webpack:///./js/main.js?')},"./js/solution/board.js":
/*!******************************!*\
  !*** ./js/solution/board.js ***!
  \******************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("const MoveError = __webpack_require__(/*! ./moveError */ \"./js/solution/moveError.js\");\n\nclass Board {\n  constructor() {\n    this.grid = Board.makeGrid();\n  }\n\n  isEmptyPos(pos) {\n    if (!Board.isValidPos(pos)) {\n      throw new MoveError('Is not valid position!');\n    }\n\n    return (this.grid[pos[0]][pos[1]] === null);\n  }\n\n  isOver() {\n    if (this.winner() != null) {\n      return true;\n    }\n\n    for (let rowIdx = 0; rowIdx < 3; rowIdx++) {\n      for (let colIdx = 0; colIdx < 3; colIdx++) {\n        if (this.isEmptyPos([rowIdx, colIdx])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  placeMark(pos, mark) {\n    if (!this.isEmptyPos(pos)) {\n      throw new MoveError('Is not an empty position!');\n    }\n\n    this.grid[pos[0]][pos[1]] = mark;\n  }\n\n  print() {\n    const strs = [];\n    for (let rowIdx = 0; rowIdx < 3; rowIdx++) {\n      const marks = [];\n      for (let colIdx = 0; colIdx < 3; colIdx++) {\n        marks.push(\n          this.grid[rowIdx][colIdx] ? this.grid[rowIdx][colIdx] : \" \"\n        );\n      }\n      strs.push(`${marks.join('|')}\\n`);\n    }\n\n    console.log(strs.join('-----\\n'));\n  }\n\n  winner() {\n    const posSeqs = [\n      // horizontals\n      [[0, 0], [0, 1], [0, 2]],\n      [[1, 0], [1, 1], [1, 2]],\n      [[2, 0], [2, 1], [2, 2]],\n      // verticals\n      [[0, 0], [1, 0], [2, 0]],\n      [[0, 1], [1, 1], [2, 1]],\n      [[0, 2], [1, 2], [2, 2]],\n      // diagonals\n      [[0, 0], [1, 1], [2, 2]],\n      [[2, 0], [1, 1], [0, 2]]\n    ];\n\n    for (let i = 0; i < posSeqs.length; i++) {\n      const winner = this.winnerHelper(posSeqs[i]);\n      if (winner != null) {\n        return winner;\n      }\n    }\n\n    return null;\n  }\n\n  winnerHelper(posSeq) {\n    for (let markIdx = 0; markIdx < Board.marks.length; markIdx++) {\n      const targetMark = Board.marks[markIdx];\n      let winner = true;\n      for (let posIdx = 0; posIdx < 3; posIdx++) {\n        const pos = posSeq[posIdx];\n        const mark = this.grid[pos[0]][pos[1]];\n\n        if (mark != targetMark) {\n          winner = false;\n        }\n      }\n\n      if (winner) {\n        return targetMark;\n      }\n    }\n\n    return null;\n  }\n\n  static isValidPos(pos) {\n    return (0 <= pos[0]) &&\n    (pos[0] < 3) &&\n    (0 <= pos[1]) &&\n    (pos[1] < 3);\n  }\n\n  static makeGrid() {\n    const grid = [];\n\n    for (let i = 0; i < 3; i++) {\n      grid.push([]);\n      for (let j = 0; j < 3; j++) {\n        grid[i].push(null);\n      }\n    }\n\n    return grid;\n  }\n}\n\nBoard.marks = ['x', 'o'];\n\nmodule.exports = Board;\n\n\n//# sourceURL=webpack:///./js/solution/board.js?")},"./js/solution/game.js":
/*!*****************************!*\
  !*** ./js/solution/game.js ***!
  \*****************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("const Board = __webpack_require__(/*! ./board */ \"./js/solution/board.js\");\nconst MoveError = __webpack_require__(/*! ./moveError */ \"./js/solution/moveError.js\");\n\nclass Game {\n  constructor() {\n    this.board = new Board();\n    this.currentPlayer = Board.marks[0];\n  }\n\n  isOver() {\n    return this.board.isOver();\n  }\n\n  playMove(pos) {\n    this.board.placeMark(pos, this.currentPlayer);\n    this.swapTurn();\n  }\n\n  promptMove(reader, callback) {\n    const game = this;\n\n    this.board.print();\n    console.log(`Current Turn: ${this.currentPlayer}`);\n\n    reader.question('Enter rowIdx: ', rowIdxStr => {\n      const rowIdx = parseInt(rowIdxStr);\n      reader.question('Enter colIdx: ', colIdxStr => {\n        const colIdx = parseInt(colIdxStr);\n        callback([rowIdx, colIdx]);\n      });\n    });\n  }\n\n  run(reader, gameCompletionCallback) {\n    this.promptMove(reader, move => {\n      try {\n        this.playMove(move);\n      } catch (e) {\n        if (e instanceof MoveError) {\n          console.log(e.msg);\n        } else {\n          throw e;\n        }\n      }\n\n      if (this.isOver()) {\n        this.board.print();\n        if (this.winner()) {\n          console.log(`${this.winner()} has won!`);\n        } else {\n          console.log('NO ONE WINS!');\n        }\n        gameCompletionCallback();\n      } else {\n        // continue loop\n        this.run(reader, gameCompletionCallback);\n      }\n    });\n  }\n\n  swapTurn() {\n    if (this.currentPlayer === Board.marks[0]) {\n      this.currentPlayer = Board.marks[1];\n    } else {\n      this.currentPlayer = Board.marks[0];\n    }\n  }\n\n  winner() {\n    return this.board.winner();\n  }\n}\n\nmodule.exports = Game;\n\n\n//# sourceURL=webpack:///./js/solution/game.js?")},"./js/solution/moveError.js":
/*!**********************************!*\
  !*** ./js/solution/moveError.js ***!
  \**********************************/
/*! no static exports found */function(module,exports){eval("\nconst MoveError = function (msg) { this.msg = msg; };\n\n// MoveError really should be a child class of the built in Error object provided\n// by Javascript, but since we haven't covered inheritance yet, we'll just\n// let it be a vanilla Object for now!\n\nmodule.exports = MoveError;\n\n\n//# sourceURL=webpack:///./js/solution/moveError.js?")},"./js/ttt-view.js":
/*!************************!*\
  !*** ./js/ttt-view.js ***!
  \************************/
/*! no static exports found */function(module,exports){eval('class View {\n  constructor(game, $el) {\n    console.log($el);\n    this.game = game;\n    this.$el = $el;\n    this.setupBoard();\n    this.bindEvents();\n  }\n\n  bindEvents() {\n    $("ul").on("click", e =>{\n      const $square = $(e.target);\n      this.makeMove($square);\n    });\n  }\n\n  makeMove($square) {\n    const pos = $square.data("pos");\n    const board = this.game.board;\n    if (!board.isEmptyPos(pos)) {\n      alert("Invalid Move!");\n    }\n    let mark = this.game.currentPlayer;\n    this.game.playMove(pos);\n    if (mark === \'x\') {\n      $square.addClass("x-clicked");\n    } else {\n      $square.addClass("o-clicked");\n    }\n    $square.append(mark);\n    if (board.isOver()) {\n      const winner = board.winner();\n      if (winner) {\n        alert(`${winner} wins!`);\n      } else {\n        alert("Cat\'s Game!");\n      }\n    }\n  }\n\n  setupBoard() {\n    const $ul = $("<ul></ul>");\n    $ul.addClass("board");\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++){\n        const $li = $("<li></li>");\n        $li.addClass("space");\n        $li.data("pos", [x, y]);\n        $ul.append($li);\n      }\n    }\n  this.$el.append($ul);\n  }\n}\n\n\n\nmodule.exports = View;\n\n\n//# sourceURL=webpack:///./js/ttt-view.js?')}})}]);